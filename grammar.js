module.exports = grammar({
  name: 'seed7',
  extras: $ => [/\s/, ';', $.comment],
  conflicts: $ => [
    [$.hash_expression, $.type],
  ],
  rules: {
    source_file: $ => repeat($._statement),
    _statement: $ => choice(
      $.block,
      $.include_statement,
      $.declaration,
      $.func_declaration,
      $._expression,
    ),
    include_statement: $ => seq(
      optional('$'),
      'include',
      $.string,
    ),
    declaration: $ => seq(
      choice('const', 'var'),
      $.type,
      ':',
      $.name,
      'is',
      choice($.type, $.value, $._expression, $.enum_expression),
    ),
    func_declaration: $ => seq(
      'const',
      'func',
      $.type,
      ':',
      $.name,
      $.parameter_list,
      'is',
      $.return_statement,
    ),
    block: $ => choice(
      $.proc_block,
      $.while_block,
      $.block_block,
      $.repeat_block,
      $.func_block,
      $.if_block,
      $.for_block,
      $.case_block,
    ),
    case_block: $ => seq(
      'case',
      choice($._expression, $.value),
      'of',
      repeat1($.case_statement),
      optional($.otherwise_block),
      'end',
      'case',
    ),
    otherwise_block: $ => seq(
      'otherwise',
      ':',
      prec.left(1, repeat1($._expression)),
    ),
    case_statement: $ => seq(
      'when',
      $.set_expression,
      ':',
      repeat1($._statement),
    ),
    func_block: $ => prec.left(1, seq(
      'const',
      'func',
      $.type,
      ':',
      $.name,
      $.parameter_list,
      'is',
      'func',
      optional($.result_block),
      optional($.local_block),
      'begin',
      repeat1($._statement),
      'end',
      'func',
    )),
    for_block: $ => seq(
      'for',
      choice($._expression, $.value, seq('key', $.name)),
      field('range', optional(
        seq(
          'range', 
          choice($._expression, $.value,
            seq(
              choice($._expression, $.value), 
              'downto', 
              choice($._expression, $.value)
            )
          )
        )
      )),
      optional(seq('until', field('until_expr', choice($._expression, $.value)))),
      'do',
      repeat($._statement),
      'end',
      'for',
    ),
    proc_block: $ => prec.left(1, seq(
      'const',
      'proc',
      ':',
      $.name,
      optional($.parameter_list),
      'is',
      'func',
      optional($.result_block),
      optional($.local_block),
      'begin',
      repeat1($._statement),
      'end',
      'func',
    )),
    result_block: $ => seq(
      'result',
      repeat1($.declaration),
    ),
    local_block: $ => seq(
      'local',
      repeat1($.declaration),
    ),
    while_block: $ => seq(
      'while',
      choice($._expression, $.value),
      'do',
      repeat($._statement),
      'end',
      'while',
    ),
    if_block: $ => seq(
      'if',
      choice($._expression, $.value),
      'then',
      repeat($._statement),
      repeat($.esif_block),
      optional($.else_block),
      'end',
      'if',
    ),
    esif_block: $ => seq(
      'elsif',
      choice($._expression, $.value),
      'then',
      repeat($._statement),
    ),
    else_block: $ => seq(
      'else',
      repeat($._statement),
    ),
    repeat_block: $ => seq(
      'repeat',
      repeat($._statement),
      'until',
      field('until_expr', choice($._expression, $.value)),
    ),
    block_block: $ => seq(
      'block',
      repeat(choice($._statement, $.exception_block)),
      'end',
      'block',
    ),
    exception_block: $ => seq(
      'exception',
      repeat1(seq('catch', $.name, ':', $._expression)),
      optional($.otherwise_block),
    ),
    return_statement: $ => seq(
      optional('return'),
      choice($._expression, $.value)
    ),
    parameter_list: $ => seq(
      '(',
      choice($.attr_param, $.param),
      repeat(seq(
        ',',
        choice($.attr_param, $.param),
      )),
      ')',
    ),
    attr_param: $ => seq(
      'attr',
      $.type,
    ),
    param: $ => seq(
      choice('val', 'ref', 'in', 'in var', 'inout'),
      $.type,
      ':',
      $.name,
    ),
    function_call: $ => prec(1, seq(
      choice($.name, $.type),
      '(',
      $.argument_list,
      ')',
    )),
    array_call: $ => prec(1, seq(
      choice($._expression, $.type),
      '[',
      $.argument_list,
      ']',
    )),
    argument_list: $ => seq(
      optional($.dotdot),
      choice($._expression, $.value, $.type),
      repeat(seq(
        ',',
        choice($._expression, $.value, $.type),
      )),
      optional($.dotdot),
    ),
    type: $ => choice(
      field('array', seq('array', $.type)),
      field('set', prec.left(1, seq('set', 'of', $.type))),
      'boolean',
      'integer',
      'bigInteger',
      'rational',
      'bigRational',
      'float',
      'complex',
      'char',
      'string',
      'hash',
      'struct',
      'bin64',
      'bin32',
      'bstring',
      'color',
      'time',
      'duration',
      'file',
      'text',
      'fileSys',
      'process',
      'category',
      'reference',
      'ref_list',
      'program',
      'ptr',
      'func', 
      'varfunc',
      'void',
      'proc',
      'type',
      'object',
      'expr',
      'bitset',
      $.unknown_type,
    ),
    unknown_type: $ => prec.right(2, $.name),
    value: $ => choice(
      $.boolean,
      $.integer,
      $.string,
      $.float,
      $.bigRational,
      $.rational,
      $.bigInteger,
      $.NIL,
      $.char,
      $.empty,
      $.STD_NULL,
      $.forward,
      $.array
    ),
    dotdot: $ => '..',
    _expression: $ => prec.right(1, seq(
      choice(
        $.binary_expression,  
        $.unary_expression,
        $.parenthesized_expression,
        $.name,
        $.function_call,
        $.value_operator,
        $.set_expression,
        $.hash_expression,
        $.struct_expression,
        $.array_call
      ),
      optional($.cast),
    )),
    NIL: $ => 'NIL',
    empty: $ => 'empty',
    STD_NULL: $ => 'STD_NULL',
    forward: $ => 'forward',
    comment: $ => token(choice(
      seq('#', /.*/),
      seq(
        '(*',
        /[^*]*\*+([^/*][^*]*\*+)*/,
        ')'
      ),
      // https://tc39.es/ecma262/#sec-html-like-comments
      seq('<!--', /.*/),
      // This allows code to exist before this token on the same line.
      //
      // Technically, --> is supposed to have nothing before it on the same line
      // except for comments and whitespace, but that is difficult to express,
      // and in general tree sitter grammars tend to prefer to be overly
      // permissive anyway.
      //
      // This approach does not appear to cause problems in practice.
      seq('-->', /.*/)
    )),
    array: $ => seq(
      '[',
      optional(field('index', $.value)),
      ']',
      '(',
      optional(seq(choice($.value, $._expression), repeat(seq(',', choice($.value, $._expression))))),
      ')',
    ),
    binary_expression: $ => prec.left(1, seq(
      field('left', choice($._expression, $.value)),
      field('operator', $.binary_operator),
      field('right', choice($._expression, $.value)),
    )),
    unary_expression: $ => prec.left(1, seq(
      field('operator', $.unary_operator),
      field('argument', choice($._expression, $.value)),
    )),
    value_operator: $ => seq(
      choice($.type, $.name, $.array_call, $.function_call, $.parenthesized_expression),
      '.',
      $.name,
    ),
    parenthesized_expression: $ => prec.left(1, seq(
      '(',
      choice($._expression, $.value),
      ')',
    )),
    set_expression: $ => choice(
      seq(
        '{',
        optional(seq(
          choice($._expression, $.value),
          repeat(seq(
            ',',
            choice($._expression, $.value),
          ))
        )),
        '}',
      ),
      seq(
        'set',
        'of',
        $.type,
      ),
    ),
    hash_expression: $ => seq(
      'hash',
      '[',
      $.type,
      ']',
      $.type,
    ),
    enum_expression: $ => seq(
      'new',
      'enum',
      $.name,
      repeat(seq(',', $.name)),
      'end',
      'enum',
    ),
    struct_expression: $ => seq(
      choice('new', 'sub'),
      optional($.type),
      'struct',
      $.declaration,
      repeat($.declaration),
      'end',
      'struct',
    ),
    binary_operator: $ => choice(
      '<>',
      '+',
      '-',
      '*',
      '/',
      'and',
      'or',
      'parse',
      'rem',
      'div',
      'mdiv',
      'mod',
      'times',
      '**',
      'lpad',
      'lpad0',
      'radix',
      'digits',
      'sci',
      'exp',
      'mult',
      ':=',
      '+:=',
      '-:=',
      '*:=',
      '<<:=',
      '>>:=',
      '/:=',
      '|:=',
      field('a', seq('@:=', '[', optional(choice($.value, $.name, $._expression)), ']')),
      field('b', seq('&:=', optional('[]'))),
      '><:=',
      '<&',
      '=',
      '&',
      '..',
      'rpad',
      'to',
      'step',
      '<',
      '>',
      '<=',
      '>=',
      'in',
      'not in',
      '|',
      'len',
      'fixLen',
      '>>',
      '<<'
    ),
    unary_operator: $ => prec.left(1,choice(
      'not',
      '-'
    )),
    boolean: $ => choice(
      'TRUE',
      'FALSE',
    ),
    name: $ => prec.right(1, seq(
      $.variable,
      optional($.cast)
    )),
    variable: $ => /[a-zA-Z_][a-zA-Z0-9_]*/,
    integer: $ => seq(
      optional('-'),
      choice(
        $._decimalLiteral,
        $._exponentialLiteral,
        $._hexLiteral,
        $._octalLiteral,
        $._binaryLiteral
      )
    ),
    cast: $ => seq(
      token.immediate('+'),
      choice($.type, $.castFunction),
    ),
    castFunction: $ => seq(
      'ord',
    ),
    _decimalLiteral: $ => /[0-9]+/,
    _exponentialLiteral: $ => /[0-9]+[eE][+]?[0-9]+/,
    _negativeExponentialLiteral: $ => /[0-9]+[eE][-]?[0-9]+/,
    _hexLiteral: $ => /16#[0-9A-Fa-f]+/,
    _octalLiteral: $ => /8#[0-7]+/,
    _binaryLiteral: $ => /2#[01]+/,
    string: $ => seq(
      '"',
      repeat(choice(
        token.immediate(prec(1, /[^"\\]+/)),
        $.escape_sequence,
      )),
      '"',
    ),
    char: $ => prec.left(1, seq(
      "'",
      repeat(choice(
        token.immediate(prec(1, /[^']+/)),
        $.escape_sequence,
      )),      
      "'",
    )),
    escape_sequence: $ => token.immediate(seq(
      '\\',
    )),
    float: $ => seq(
      choice($._decimalLiteral, $._exponentialLiteral, $._negativeExponentialLiteral),
      '.',
      choice($._decimalLiteral, $._exponentialLiteral, $._negativeExponentialLiteral),
    ),
    bigRational: $ => seq(
      choice($._decimalLiteral),
      '_/',
      choice($._decimalLiteral),
      '_',
    ),
    rational: $ => prec(1,seq(
      choice($._decimalLiteral),
      '/',
      choice($._decimalLiteral),
    )),
    bigInteger: $ => seq(
      $.integer,
      '_',
    ),
    escape_sequence: $ => prec.left(1, seq(
      '\\',
      choice(
        /./,
        $.value,
        "'",
        '"',
      ),
    )),
  }
})